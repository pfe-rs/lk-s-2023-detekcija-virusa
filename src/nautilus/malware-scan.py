#!/usr/bin/env python3

import os
import subprocess
import gi
gi.require_version('Gtk', '4.0')
from gi.repository import Nautilus, GObject, Gtk, Gio

SCAN_SCRIPT = "/scan.sh"
SCAN_RESULTS_DIR = os.path.join(os.environ["HOME"], "PFE/malware_scan_results")
dialog_ref = []

class MalwareScannerExtension(GObject.GObject, Nautilus.MenuProvider):
    def get_file_items(self, files):
        if len(files) > 0:
            item = Nautilus.MenuItem(name="MalwareScanner::Scan", label="Scan for malware", icon="")

            item.connect('activate', self.menu_activate_cb, files)
            return [item]
        return []

    def menu_activate_cb(self, menu, files):
        if len(files) > 1:
            self.many_selected = True
        else:
            self.many_selected = False
        for file in files:
            self._scan_file(file)

    def _scan_file(self, file):
        if file.is_directory():
            handler = Gio.File.new_for_uri(file.get_uri())
            file_list = self._traverse(handler.get_path())
        else:
            handler = Gio.File.new_for_uri(file.get_uri())
            file_list = [handler.get_path()]

        if not os.path.exists(SCAN_RESULTS_DIR):
            os.makedirs(SCAN_RESULTS_DIR)

        for i, path in enumerate(file_list):
            virus_name = os.path.basename(path)
            container_name = f"malware_scan_{i}"

            if self._check_magic_elf(path) and self._check_arch_elf(path):
                print(f"Trying {path}")
                try:
                    subprocess.run(["docker", "run", "-d", "--name", container_name, "ubuntu", "pause"], capture_output=True, check=True)
                    subprocess.run(["docker", "cp", path, f"{container_name}:/virus"], capture_output=True, check=True)
                    subprocess.run(["docker", "exec", "-it", container_name, SCAN_SCRIPT, "10"])
                    subprocess.run(["docker", "cp", f"{container_name}:/features", f"{SCAN_RESULTS_DIR}/log_{virus_name}"], capture_output=True, check=True)
                    subprocess.run(["docker", "stop", "--time=0", container_name], capture_output=True, check=True)
                    subprocess.run(["docker", "rm", container_name], capture_output=True, check=True)
                except subprocess.CalledProcessError as e:
                    subprocess.run(["docker", "stop", "--time=0", container_name])
                    subprocess.run(["docker", "rm", container_name])
                    self._error_dialog("Docker: " + e.stderr.decode())
            else:
                if self._check_magic_exe(path):
                    try:
                        home = os.environ["HOME"]
                        subprocess.run(["cp", path, f"{home}/.var/app/com.usebottles.bottles/data/bottles/bottles/Malware/drive_c/virus"], capture_output=True, check=True)
                        completedProcess = subprocess.run(["timeout", "10", "flatpak", "run", "--command=bottles-cli", "--env=WINEDEBUG=+relay", "com.usebottles.bottles", "run", "-b", "Malware", "-e", "C:\\virus"], capture_output=True, check=True)
                        subprocess.run(["snapshot", "delete", f"{home}/.var/app/com.usebottles.bottles"], capture_output=True, check=True)
                        subprocess.run(["snapshot", "create", f"{home}/.var/app/bottles-backup", f"{home}/.var/app/com.usebottles.bottles"], capture_output=True, check=True)
                    except subprocess.CalledProcessError as e:
                        if e.returncode != 124:
                            str = e.stderr.decode()
                            str = str.splitlines()
                            self._error_dialog("Bottles: " + str[-1])
                            return
                        completedProcess = e
                    with open(f"{SCAN_RESULTS_DIR}/log_{virus_name}", "w") as f:
                        f.write(completedProcess.stderr)
                else:
                    if not self.many_selected and len(file_list) == 1:
                        self._error_dialog("Invalid file. Please provide a valid ELF or EXE file for x86-64 architecture.")

    def _traverse(self, dir_path:str):
        file_list = []
        for dirpath, dirnames, filenames in os.walk(dir_path):
            for filename in filenames:
                file_list.append(os.path.join(dirpath, filename))
        return file_list
    
    def _check_magic_exe(self, path:str):
        with open(path, "rb") as f:
            magic = f.read(2)
            if magic == b'MZ':
                return True
        return False

    def _check_magic_elf(self, path:str):
        with open(path, "rb") as f:
            magic_bytes = f.read(4)
            return magic_bytes == b"\x7FELF"
        
    def _check_arch_elf(self, path:str):
        with open(path, "rb") as f:
            f.seek(18)  # The e_machine field in the ELF header is at offset 0x12 (18 bytes)
            machine_bytes = f.read(2)   # e_machine [=] Elf64_half [=] uint_16
            return machine_bytes in [b"\x03\x00", b"\x3E\x00"]  # 3 for x86, 62 for x86-64

    def _error_dialog(self, message:str):
        dialog = Gtk.MessageDialog(
            modal=True,
            buttons=Gtk.ButtonsType.OK,
            message_type=Gtk.MessageType.ERROR,
            text="Error",
            secondary_text=message
        )
        index = self._add_dialog_ref(dialog)
        dialog.connect("response", self._destroy_dialog, index)
        dialog.show()
    
    def _destroy_dialog(self, dialog:Gtk.MessageDialog, response_id:int, index:int):
        dialog.destroy()
        global dialog_ref
        dialog_ref[index] = None

    def _add_dialog_ref(self, dialog:Gtk.MessageDialog):
        global dialog_ref
        for i in range(len(dialog_ref)):
            if dialog_ref[i] == None:
                dialog_ref[i] = dialog
                return i
        dialog_ref.append(dialog)
        return len(dialog_ref)-1
